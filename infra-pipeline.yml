name: $(Date:yyyyMMdd)$(Rev:.r)-Infrastructure
trigger: none
pr: none

parameters:
  - name: env
    displayName: Environment
    type: string
    default: nonprod
    values: [nonprod, prod]

  - name: destroy
    displayName: Destroy
    type: boolean
    default: false

variables:
  TF_DIR: 'terraform'
  TF_VAR_FILE: '${{ parameters.env }}.tfvars'
  AWS_SERVICE_CONNECTION: 'aws-awwad'
  AWS_REGION: 'eu-central-1'

pool:
  vmImage: ubuntu-latest

jobs:
- job: Infrastructure
  displayName: 'Infrastructure Provisioning (VPC, EKS, Cognito, APIGW)'
  timeoutInMinutes: 120

  steps:
  - checkout: self

  - task: TerraformInstaller@1
    displayName: Install Terraform
    inputs:
      terraformVersion: latest

  # -------------------------
  # Terraform Init + State Cleanup
  # -------------------------
  - task: AWSShellScript@1
    displayName: Terraform Init
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail
        cd "$(TF_DIR)"

        terraform init

        echo "Checking for legacy Kubernetes / Helm resources in state..."

        STATE_LIST="$(terraform state list 2>/dev/null || true)"

        if [ -z "$STATE_LIST" ]; then
          echo "No state file found or state is empty."
          exit 0
        fi

        for resource in $(echo "$STATE_LIST" | grep -E '^kubernetes_' || true); do
          echo "Removing ${resource} from state..."
          terraform state rm "${resource}" || true
        done

        for resource in $(echo "$STATE_LIST" | grep -E '^helm_' || true); do
          echo "Removing ${resource} from state..."
          terraform state rm "${resource}" || true
        done

  # -------------------------
  # Terraform Apply / Destroy
  # -------------------------
  - task: AWSShellScript@1
    displayName: Terraform Apply or Destroy
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail
        cd "$(TF_DIR)"

        if [ "${{ parameters.destroy }}" = "True" ]; then
          echo "=== DESTROY MODE ==="

          # Remove legacy namespace if present
          terraform state list 2>/dev/null | grep -q "kubernetes_namespace_v1.ingress_nginx" && \
            terraform state rm kubernetes_namespace_v1.ingress_nginx || true

          if terraform output -raw vpc_id >/dev/null 2>&1; then
            VPC_ID="$(terraform output -raw vpc_id)"
            echo "Target VPC ID: $VPC_ID"

            # --- API Gateway VPC Links ---
            VPC_LINK_IDS="$(aws apigatewayv2 get-vpc-links \
              --query 'Items[].VpcLinkId' \
              --output text 2>/dev/null || true)"

            for link_id in $VPC_LINK_IDS; do
              echo "Deleting API Gateway VPC Link: $link_id"
              aws apigatewayv2 delete-vpc-link --vpc-link-id "$link_id" || true
            done

            [ -n "$VPC_LINK_IDS" ] && sleep 60

            # --- Classic ELBs ---
            for elb in $(aws elb describe-load-balancers \
              --query "LoadBalancerDescriptions[?VPCId=='$VPC_ID'].LoadBalancerName" \
              --output text 2>/dev/null || true); do
              echo "Deleting Classic ELB: $elb"
              aws elb delete-load-balancer --load-balancer-name "$elb" || true
            done

            # --- ALB / NLB ---
            for arn in $(aws elbv2 describe-load-balancers \
              --query "LoadBalancers[?VpcId=='$VPC_ID'].LoadBalancerArn" \
              --output text 2>/dev/null || true); do
              echo "Deleting ELBv2: $arn"
              aws elbv2 delete-load-balancer --load-balancer-arn "$arn" || true
            done

            sleep 30

            # --- Orphaned ENIs ---
            for eni in $(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=status,Values=available" \
              --query 'NetworkInterfaces[].NetworkInterfaceId' \
              --output text 2>/dev/null || true); do
              echo "Deleting orphaned ENI: $eni"
              aws ec2 delete-network-interface --network-interface-id "$eni" || true
            done

            # --- Detach + delete in-use ENIs ---
            aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=status,Values=in-use" \
              --query "NetworkInterfaces[?Attachment.DeleteOnTermination==\`false\` && !starts_with(Description, 'Amazon EKS')].[NetworkInterfaceId,Attachment.AttachmentId]" \
              --output text 2>/dev/null | \
            while read -r eni attach; do
              [ -z "$eni" ] && continue
              echo "Detaching ENI: $eni"
              aws ec2 detach-network-interface --attachment-id "$attach" --force || true
            done

            sleep 30

            for eni in $(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=status,Values=available" \
              --query 'NetworkInterfaces[].NetworkInterfaceId' \
              --output text 2>/dev/null || true); do
              echo "Deleting detached ENI: $eni"
              aws ec2 delete-network-interface --network-interface-id "$eni" || true
            done
          fi

          echo "=== Running Terraform Destroy ==="
          terraform destroy -auto-approve -refresh=false -var-file="$(TF_VAR_FILE)" || \
          terraform destroy -auto-approve -var-file="$(TF_VAR_FILE)"
          exit 0
        fi

        echo "=== Running Terraform Apply ==="
        terraform apply -auto-approve -var-file="$(TF_VAR_FILE)"
